/*
 *  UART
 *
 *  Copyright (C) 2020, Hensoldt Cyber GmbH
 */


import <if_OS_BlockingWrite.camkes>;

//------------------------------------------------------------------------------
// Components

#define DECLARE_COMPONENT_UART_HW(_type_) \
    \
    component _type_ { \
        hardware; \
        \
        dataport  Buf  mmio_regBase; \
        emits     IRQ  irq; \
    }


#define UART_DRV_EXPORTED_MEMBERS \
    provides  if_OS_BlockingWrite   UartDrv; \
    dataport  Buf                   Uart_inputDataport; \
    dataport  Buf                   Uart_outputFifoDataport; \
    emits     EventDataAvailable    Uart_DataAvailable;


#define DECLARE_COMPONENT_UART_DRV(_type_) \
    \
    component _type_ { \
        dataport  Buf  mmio_regBase; \
        consumes  IRQ  irq; \
        \
        UART_DRV_EXPORTED_MEMBERS \
    }


//------------------------------------------------------------------------------
// Instance Connection

#define DECLARE_AND_CONNECT_INSTANCE_UART_DRV_HW( \
    _type_hw_, \
    _inst_hw_, \
    _type_drv_, \
    _inst_drv_) \
    \
    component   _type_hw_    _inst_hw_; \
    component   _type_drv_   _inst_drv_; \
    \
    connection  seL4HardwareMMIO       _inst_drv_ ## _ ## _inst_hw_ ## _mmio( \
                from _inst_drv_.mmio_regBase, \
                to   _inst_hw_.mmio_regBase); \
    \
    connection  seL4HardwareInterrupt  _inst_drv_ ## _ ## _inst_hw_ ## _irq( \
                from _inst_hw_.irq, \
                to   _inst_drv_.irq);


//------------------------------------------------------------------------------
// Component based on Composition
//
// ToDo: we pass paddr and irq as parameters here, because making this
//       attributes does not work as expected, see commented out lines.

#define DECLARE_COMPONENT_UART(_type_, _paddr_, _irq_) \
    \
    DECLARE_COMPONENT_UART_HW( _type_ ## _hw ) \
    DECLARE_COMPONENT_UART_DRV( _type_ ## _drv ) \
    \
    component _type_ { \
        \
        UART_DRV_EXPORTED_MEMBERS \
        \
        /* attribute  int  paddr; */ \
        /* attribute  int  irq; */ \
        \
        composition { \
            \
            DECLARE_AND_CONNECT_INSTANCE_UART_DRV_HW( \
                _type_ ## _hw, \
                inst_ ## _type_ ## _hw, \
                _type_ ## _drv, \
                inst_ ## _type_ ## _drv ) \
            \
            export inst_ ## _type_ ## _drv.UartDrv                  -> UartDrv; \
            export inst_ ## _type_ ## _drv.Uart_inputDataport       -> Uart_inputDataport; \
            export inst_ ## _type_ ## _drv.Uart_outputFifoDataport  -> Uart_outputFifoDataport; \
            export inst_ ## _type_ ## _drv.Uart_DataAvailable       -> Uart_DataAvailable; \
            \
        } \
        \
        configuration { \
            \
            inst_ ## _type_ ## _hw.mmio_regBase_size  = 0x1000; \
            inst_ ## _type_ ## _drv.input_port = "R"; \
            \
            /* inst_ ## _type_ ## _hw.mmio_regBase_paddr  <- paddr; */ \
            /* inst_ ## _type_ ## _hw.irq_irq_number      <- irq_irq_number; */ \
            \
            inst_ ## _type_ ## _hw.mmio_regBase_paddr = _paddr_; \
            inst_ ## _type_ ## _hw.irq_irq_number     = _irq_; \
        } \
    }



//------------------------------------------------------------------------------
// Instance Configuration

#define CONFIGURE_INSTANCE_UART(_inst_, _phys_addr_, _irq_) \
    \
    _inst_.paddr = _phys_addr_; \
    _inst_.irq   = _irq_;
