/*
 *  UART
 *
 *  Copyright (C) 2020, Hensoldt Cyber GmbH
 */

#pragma once

import <std_connector.camkes>;
import <if_OS_BlockingWrite.camkes>;

#if !defined(Uart_INPUT_FIFO_DATAPORT_SIZE)
#   define Uart_DECLARE_INPUT_FIFO_DATAPORT()\
    dataport  Buf Uart_inputFifoDataport
#elif (Uart_INPUT_FIFO_DATAPORT_SIZE % 4096 != 0)
#   error "please make sure that Uart_INPUT_FIFO_DATAPORT_SIZE is defined as a multiple of 4096".
#else
#   define Uart_DECLARE_INPUT_FIFO_DATAPORT()\
    dataport  Buf(Uart_INPUT_FIFO_DATAPORT_SIZE) Uart_inputFifoDataport
#endif


#define UART_COMPONENT_DEFINE(_type_, _dtb_name_) \
    \
    component _type_ { \
        \
        provides  if_OS_BlockingWrite   UartDrv; \
        Uart_DECLARE_INPUT_FIFO_DATAPORT(); \
        dataport  Buf                   Uart_outputDataport; \
        emits     EventDataAvailable    Uart_DataAvailable; \
        \
        emits     Dummy  hw_src; \
        consumes  Dummy  dev; \
        \
        composition { \
            connection seL4DTBHardware con_hw(from hw_src, to dev); \
        } \
        \
        configuration { \
            dev.dtb = dtb(_dtb_name_); \
            dev.generate_interrupts = 1; \
        } \
    } \


// platform specific UART details
#include "UART_plat_config.camkes"


#define UART_INSTANCE_CONNECT_CLIENT(\
    _inst_,\
    _client_rpc_,\
    _client_input_port_,\
    _client_output_port_,\
    _client_has_data_) \
    \
    connection  seL4RPCCall _inst_ ## _Uart_rpc( \
        from _client_rpc_, \
        to   _inst_.UartDrv); \
    \
    connection  seL4SharedData  _inst_ ## _Uart_inputDataport( \
        from _inst_.Uart_inputFifoDataport, \
        to   _client_input_port_); \
    \
    connection  seL4SharedData  _inst_ ## _Uart_outputFifoDataport( \
        from _client_output_port_, \
        to   _inst_.Uart_outputDataport); \
    \
    connection  seL4Notification  _inst_ ## Uart_DataAvailable( \
        from _inst_.Uart_DataAvailable, \
        to   _client_has_data_);
